<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Basalt Site Data Entry</title>
  <!-- PWA Manifest -->
  <link rel="manifest" href="/manifest.json">
  <!-- Favicon -->
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <style>
    body { font-family: sans-serif; margin: 16px; }
    .machine-section, .delivery-section, .delivery-entry { border: 1px solid #ccc; padding: 12px; margin-bottom: 16px; border-radius: 8px; }
    .resource-row, .delivery-entry .resource-row { display: flex; gap: 8px; margin-top: 8px; align-items: center; }
    .resource-row input, .resource-row select { flex: 1; }
    .btn { padding: 5px 8px; margin-top: 6px; cursor: pointer; border: none; border-radius: 3px; background: #2196f3; color: white; font-size:0.85em; }
    .btn.small { padding: 4px 8px; font-size: 0.9em; }
    .stock-card { display: inline-block; padding: 6px; margin: 3px; border: 1px solid #888; border-radius: 4px; cursor: default; position: relative; width: 120px; vertical-align: top; font-size: 0.85em; }
    .stock-card .resource-name { font-weight: bold; display: block; margin-bottom: 3px; text-align: center; font-size: 0.95em; cursor: pointer; } /* Make name clickable */
    .stock-card .stock-delta { font-size:0.8em; margin: 1px 0; }
    .stock-card .stock-value { font-size: 1em; font-weight: bold; margin: 4px 0; display: block; }
    .stock-card .measured-stock-display { font-size: 0.8em; color: #555; margin-top: 3px; }
    .stock-card.disabled { cursor: not-allowed; opacity: 0.6; }
    .stock-card.disabled:hover { background: none; } /* Prevent hover effect when disabled */
    .stock-card .badge { position: absolute; top: -6px; right: -6px; background: red; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 0.8em; }
    .stock-card:hover { background: #f0f0f0; }
  </style>
  <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script>
</head>
<body>
  <h2>Daily Entry</h2>
  <label>Date: <input type="date" id="entry-date" name="entry-date" required></label>


  <datalist id="machine-list"></datalist>

  <div class="stock-info-section">
    <h3>Resource Stock & Checks</h3>
    <div id="resource-stock-cards-container"></div> <!-- Container for stock cards -->
  </div>

  <form id="entry-form">
    <div id="machines-container"></div>
    <button type="button" class="btn" id="add-machine">+ Add Machine</button> <!-- This button will be hidden/shown -->
    <button type="submit" class="btn" id="save-entries-btn">Save All Entries</button>
    <button type="button" class="btn" id="edit-entries-btn" style="display:none;">Edit Entries</button> <!-- Initially hidden -->
  </form>
  <!-- This p#status will be used by app.js as syncStatus -->
  <p id="syncStatus">Loading status...</p>

  <template id="machine-template">
    <div class="machine-section">
      <label>Machine: <input name="machine" list="machine-list" required></label>
      <div class="resources-container"></div>
      <div>
        <label style="font-size: 0.9em; margin-top: 8px;">Notes for this machine:</label>
        <textarea name="machine-notes" rows="2" style="width: 100%; box-sizing: border-box; font-size: 0.9em;"></textarea>
      </div>
      <button type="button" class="btn small add-resource">+ Add Resource</button>
    </div>
  </template>

  <template id="resource-template">
    <div class="resource-row">
      <select name="resource">
        <option>Gasoil</option>
        <option>HuileMoteur</option>
        <option>HuileHydraulique</option>
        <option>HuileLubrification</option>
        <option>HuileBoite</option>
        <option>HuilePont</option>
        <option>HuileDirection</option>
      </select>
      <input name="quantity" type="number" placeholder="Quantity" required>
      <button type="button" class="btn small remove-resource">✕</button>
    </div>
  </template>

  <button type="button" class="btn" id="manual-sync-btn" style="margin-top: 20px;">Sync Now</button>

  <script>
    // Prepopulate date
    const dateInput = document.getElementById('entry-date');
    dateInput.valueAsDate = new Date();


    // Sample machine list; populate datalist
    const machineOptions = ['EXC-300','BULL-24','CRANE-12', 'Livraison'];
    const machineList = document.getElementById('machine-list');
    machineOptions.forEach(m => {
      const opt = document.createElement('option'); opt.value = m; machineList.appendChild(opt);
    });

    // Setup machines
    const machinesContainer = document.getElementById('machines-container');
    const addMachineBtn = document.getElementById('add-machine');
    addMachineBtn.onclick = addMachineSection;

    function addMachineSection() {
      const clone = document.getElementById('machine-template').content.cloneNode(true);
      const section = clone.querySelector('.machine-section');
      section.querySelector('.add-resource').onclick = () => addResourceRow(section);
      machinesContainer.appendChild(section);
      return section; // Return the added section
    }
    function addResourceRow(section) {
      const clone = document.getElementById('resource-template').content.cloneNode(true);
      const row = clone.querySelector('.resource-row');
      row.querySelector('.remove-resource').onclick = () => row.remove();
      section.querySelector('.resources-container').appendChild(row);
      return row; // Return the added row
    }
    // addMachineSection(); // Don't add one by default, loadEntriesForDate will handle it or user adds
    // machinesContainer.querySelector('.machine-section .add-resource').click(); // Don't add one by default

    // Resource Stock Cards Setup
    const resources = ['Gasoil','HuileMoteur','HuileHydraulique','HuileLubrification','HuileBoite','HuilePont','HuileDirection'];
    const resourceStockCardsContainer = document.getElementById('resource-stock-cards-container');

    resources.forEach(r => {
      const card = document.createElement('div');
      card.className = 'stock-card';
      card.dataset.resource = r;
      card.innerHTML = `
        <span class="resource-name">${r}</span> 
        <div class="stock-value">Stock: N/A</div>
        <div class="stock-delta">Δ Today: +0 | -0</div>
        <div class="measured-stock-display">Measured: N/A</div>
      `;

      // Make the card (or just the resource name) clickable to enter measured stock
      card.querySelector('.resource-name').addEventListener('click', () => {
        // Check if the main "Edit" button is hidden, which implies we are in an editable state.
        // Also ensure the card itself isn't explicitly disabled (though setFormEditable should handle this).
        const isInEditableMode = editBtn.style.display === 'none';
        if (isInEditableMode && !card.classList.contains('disabled')) {
          console.log(`Prompting for measured stock for ${r}. Form is editable, card is not disabled.`);
          promptForMeasuredStock(r, card);
        } else {
          console.log(`Not prompting for ${r}. isInEditableMode (editBtn hidden): ${isInEditableMode}, card.disabled: ${card.classList.contains('disabled')}`);
        }
      });
      resourceStockCardsContainer.appendChild(card);
    });
    // updateBadge function is removed as badges are no longer used on stock cards.

    // Submit handler
    document.getElementById('entry-form').addEventListener('submit', async e => {
      e.preventDefault();
      const entryDateValue = document.getElementById('entry-date').value;
      // Assuming a general notes field is added to the form
      const generalNotes = document.getElementById('general-notes').value || '';

      let entriesSavedCount = 0;

      // Deliveries are now handled as part of the machineSections.
      // If a machine name is "Livraison (ResourceName)", it's treated as a delivery.

      // Gather machine usage entries
      const machineSections = machinesContainer.querySelectorAll('.machine-section');
      
      // Before saving new entries, delete any existing entries for this date
      await deleteEntriesByDate(entryDateValue); // from app.js
      
      for (const section of machineSections) { // Changed from forEach
        const machineName = section.querySelector('input[name="machine"]').value;
        const machineNotes = section.querySelector('textarea[name="machine-notes"]')?.value || ''; // Assuming notes per machine section

        const resourceRows = section.querySelectorAll('.resource-row');
        for (const row of resourceRows) { // Changed from forEach
          const resource = row.querySelector('select[name="resource"]').value;
          const quantity = parseFloat(row.querySelector('input[name="quantity"]').value);
          let actualMachineName = machineName;

          // Check if this machine entry is intended as a "Livraison" for this specific resource
          if (machineName.toLowerCase().trim().startsWith('livraison')) {
            actualMachineName = 'Livraison'; // Set to just "Livraison"
            // If the user typed something like "Livraison Gasoil" but the resource row is "HuileMoteur",
            // we should skip this row for this "Livraison Gasoil" machine entry.
            // Only save if the original machine name was exactly "Livraison" OR if it included the resource name.
            const originalMachineLower = machineName.toLowerCase().trim();
            const resourceLower = resource.toLowerCase();
            if (originalMachineLower !== 'livraison' && !originalMachineLower.includes(resourceLower)) {
                continue;
            }
          }
          const usageEntryData = {
            date: entryDateValue,
            machine: actualMachineName, // Use standardized or actual machine name
            resource: resource,
            quantity: quantity,
            notes: `${generalNotes} ${machineNotes}`.trim(), // Combine general and machine notes
            status: 'queued'
          };

          if (!isNaN(quantity) && quantity > 0 && machineName) {
            await addFormEntry(usageEntryData);
            entriesSavedCount++;
          }
        }
      }

      if (entriesSavedCount > 0) { // Check if *any* entries were saved
        document.getElementById('syncStatus').textContent = `${entriesSavedCount} entries saved/updated locally and queued for sync.`;

        // // Optionally, trigger sync immediately if online - REMOVED FOR MANUAL SYNC
        // if (navigator.onLine && typeof syncQueuedEntries === 'function') {
        //   syncQueuedEntries();
        // }
        await loadEntriesForDate(entryDateValue); // Reload to switch to view mode
      } else {
        document.getElementById('syncStatus').textContent = 'No new entries to save.';
        // If no entries were saved, but we might have deleted old ones, still reload.
        if (await getEntriesByDate(entryDateValue).then(e => e.length === 0)) { // Check if db is empty for the day
            await loadEntriesForDate(entryDateValue); // Reload to ensure UI is in correct state (e.g. editable)
        }
      }
    });

    // Register Service Worker
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/service-worker.js')
          .then(reg => console.log('Service Worker: Registered', reg))
          .catch(err => console.error('Service Worker: Registration Error', err));
      });
    }
  </script>

  <script>
    // --- UI Mode and Data Loading Logic ---
    const saveBtn = document.getElementById('save-entries-btn');
    const editBtn = document.getElementById('edit-entries-btn');
    const manualSyncBtn = document.getElementById('manual-sync-btn');
    const generalNotesInput = document.getElementById('general-notes');

    // Store for today's stock check overrides. Key: resourceName, Value: quantityOnHand
    let dailyStockCheckOverrides = {};


    function setFormEditable(isEditable) {
      // Toggle readOnly/disabled for inputs, selects, textareas
      document.querySelectorAll('#entry-form input, #entry-form select, #entry-form textarea, #general-notes').forEach(el => {
        if (el.id === 'entry-date') { // Date input should always be changeable
          el.readOnly = false; // Allow changing date
          el.disabled = false;
        } else {
          el.readOnly = !isEditable;
          el.disabled = !isEditable;
        }
      });

      // Toggle disabled state for resource cards
      document.querySelectorAll('.stock-card').forEach(card => {
        isEditable ? card.classList.remove('disabled') : card.classList.add('disabled');
      });

      // Show/hide add/remove buttons within dynamic sections
      document.querySelectorAll('.add-resource, .remove-resource, .remove-delivery').forEach(btn => {
        btn.style.display = isEditable ? '' : 'none';
      });

      // Toggle main action buttons
      addMachineBtn.style.display = isEditable ? '' : 'none';
      saveBtn.style.display = isEditable ? '' : 'none';
      saveBtn.textContent = isEditable ? (editBtn.style.display === 'none' ? 'Save All Entries' : 'Update Entries') : 'Save All Entries';
      editBtn.style.display = isEditable ? 'none' : '';
      

      updateSyncButtonState(); // from app.js
    }

    editBtn.addEventListener('click', () => {
      setFormEditable(true);
      saveBtn.textContent = 'Update Entries';
      document.getElementById('syncStatus').textContent = 'Form is now editable for update.';
    });

    manualSyncBtn.addEventListener('click', () => {
      if (navigator.onLine) {
        syncQueuedEntries(true, true); // from app.js (showStatus=true, manualTrigger=true)
      } else {
        alert('Cannot sync while offline.');
      }
    });

    async function updateCardStockDisplay(resourceName, forDate) {
      const cardElement = resourceStockCardsContainer.querySelector(`.stock-card[data-resource="${resourceName}"]`);
      if (!cardElement) return;

      let baseStockQty = 0;
      // Priority 1: Use today's measured stock if available (from override or DB)
      if (dailyStockCheckOverrides[forDate] && dailyStockCheckOverrides[forDate][resourceName] !== undefined) {
        baseStockQty = dailyStockCheckOverrides[forDate][resourceName];
      } else {
        const todayStockCheck = await db.stockChecks.get([resourceName, forDate]); // from app.js, using compound key

        if (todayStockCheck) {
          baseStockQty = todayStockCheck.quantityOnHand;
          // Store it in override if not already there for today
          if (!dailyStockCheckOverrides[forDate]) dailyStockCheckOverrides[forDate] = {};
          dailyStockCheckOverrides[forDate][resourceName] = baseStockQty;
        } else {
          // Priority 2: Use most recent stock check before today
          const recentCheck = await getMostRecentStockCheck(resourceName, forDate); // from app.js
          if (recentCheck) {
            baseStockQty = recentCheck.quantityOnHand;
          }
        }
      }

      // Fetch all form entries for the current date to calculate net movement
      const formEntriesToday = await getEntriesByDate(forDate); // from app.js
      let sumDeliveriesToday = 0;
      let sumUsagesToday = 0;

      formEntriesToday.forEach(entry => {
        if (entry.resource === resourceName) {
          if (entry.machine.toLowerCase().startsWith('livraison')) {
            sumDeliveriesToday += entry.quantity;
          } else {
            sumUsagesToday += entry.quantity;
          }
        }
      });
      
      let netMovementToday = sumDeliveriesToday - sumUsagesToday;

      // If a stock check was performed today, that IS the current stock.
      // The netMovement is then relative to that check for any *subsequent* entries.
      // For display, we show the base (which could be today's check) + net movement of *all* entries for the day.
      // The "Δ Today" shows the gross movements.
      const displayStock = (dailyStockCheckOverrides[forDate] && dailyStockCheckOverrides[forDate][resourceName] !== undefined)
                           ? dailyStockCheckOverrides[forDate][resourceName] + netMovementSinceLastCheck(resourceName, forDate, formEntriesToday, dailyStockCheckOverrides[forDate][resourceName])
                           : baseStockQty + netMovementToday;

      const stockValueEl = cardElement.querySelector('.stock-value');
      if (stockValueEl) stockValueEl.textContent = `Stock: ${displayStock.toFixed(1)}`;

      const measuredDisplayEl = cardElement.querySelector('.measured-stock-display');
      if (measuredDisplayEl) {
        const todayMeasured = dailyStockCheckOverrides[forDate] && dailyStockCheckOverrides[forDate][resourceName] !== undefined 
                              ? dailyStockCheckOverrides[forDate][resourceName] : 'N/A';
        measuredDisplayEl.textContent = `Measured: ${todayMeasured}`;
      }

      const deltaEl = cardElement.querySelector('.stock-delta');
      if (deltaEl) deltaEl.textContent = `Δ Today: +${sumDeliveriesToday.toFixed(1)} | -${sumUsagesToday.toFixed(1)}`;
    }

    async function handleSaveStockCheck(resourceName, cardElement, quantityOnHandFromPrompt) {
      const forDate = dateInput.value;
      // const measuredStockInput = cardElement.querySelector('.measured-stock-input'); // This input no longer exists on the card
      // const quantityOnHand = parseFloat(measuredStockInput.value); // Value now comes from prompt

      if (isNaN(quantityOnHandFromPrompt)) { // Validate the passed value
        // This validation should ideally happen in promptForMeasuredStock before calling this, but good to double check
        return;
      }

      await saveStockCheck({ resourceName, date: forDate, quantityOnHand: quantityOnHandFromPrompt, synced: false }); // from app.js
      if (!dailyStockCheckOverrides[forDate]) dailyStockCheckOverrides[forDate] = {};
      dailyStockCheckOverrides[forDate][resourceName] = quantityOnHandFromPrompt; // Set override

      await updateCardStockDisplay(resourceName, forDate); // Refresh card display
      alert(`Stock check for ${resourceName} on ${forDate} saved: ${quantityOnHandFromPrompt}.`);
    }

    function promptForMeasuredStock(resourceName, cardElement) {
      const forDate = dateInput.value;
      let currentMeasured = (dailyStockCheckOverrides[forDate] && dailyStockCheckOverrides[forDate][resourceName] !== undefined)
                              ? dailyStockCheckOverrides[forDate][resourceName]
                              : '';
      const measuredStockStr = prompt(`Enter measured stock for ${resourceName} on ${forDate}:`, currentMeasured);

      if (measuredStockStr === null) return; // User cancelled

      const quantityOnHand = parseFloat(measuredStockStr);
      if (isNaN(quantityOnHand)) {
        alert('Please enter a valid number for measured stock.');
        return;
      }
      handleSaveStockCheck(resourceName, cardElement, quantityOnHand); // Pass the validated quantity
    }

    async function loadEntriesForDate(dateString) {
      console.log(`Loading entries for date: ${dateString}`);
      document.getElementById('syncStatus').textContent = `Loading entries for ${dateString}...`;
      clearAllFormEntries();
      if (!dailyStockCheckOverrides[dateString]) dailyStockCheckOverrides[dateString] = {}; // Init overrides for the day

      const entries = await getEntriesByDate(dateString); // from app.js

      if (entries && entries.length > 0) {
        document.getElementById('syncStatus').textContent = `Displaying ${entries.length} saved entries for ${dateString}.`;
        let notesLoaded = false;

        entries.forEach(entry => {
          // All entries (deliveries and usages) are loaded into the machinesContainer
          // If entry.machine starts with "Livraison", it's a delivery.
          // The submit handler already correctly saves these.
          // Here, we just populate the machine sections.
          { 
            let machineSection = Array.from(machinesContainer.querySelectorAll('.machine-section'))
                                     .find(ms => ms.querySelector('input[name="machine"]').value === entry.machine);
            if (!machineSection) {
              machineSection = addMachineSection();
              machineSection.querySelector('input[name="machine"]').value = entry.machine;
              if (entry.notes && machineSection.querySelector('textarea[name="machine-notes"]')) { // Populate machine specific notes if available
                 machineSection.querySelector('textarea[name="machine-notes"]').value = entry.notes; // Assuming notes on entry are machine specific here
              }
            }
            const resourceRow = addResourceRow(machineSection);
            resourceRow.querySelector('select[name="resource"]').value = entry.resource;
            resourceRow.querySelector('input[name="quantity"]').value = entry.quantity;
            resourceRow.querySelector('input[name="quantity"]').addEventListener('input', () => { // Add listener for live update
                updateCardStockDisplay(entry.resource, dateString);
            });
          }
          // Populate general notes from the first entry that has notes
          if (!notesLoaded && entry.notes && generalNotesInput) {
            generalNotesInput.value = entry.notes; // Or a specific field if general notes are separate
            notesLoaded = true;
          }
        });
        setFormEditable(false); // View mode
        saveBtn.textContent = 'Save All Entries'; // Reset button text, edit will change it
      } else {
        document.getElementById('syncStatus').textContent = `No entries found for ${dateString}. Ready for new input.`;
        addMachineSection(); // Add one blank machine section for new entry
        setFormEditable(true); // Edit mode
        saveBtn.textContent = 'Save All Entries';
      }

      // After populating form, update all card stock displays
      document.querySelectorAll('.stock-card').forEach(card => {
        updateCardStockDisplay(card.dataset.resource, dateString);
      });
    }

    function clearAllFormEntries() {
      machinesContainer.innerHTML = '';
      if (generalNotesInput) generalNotesInput.value = '';
      resources.forEach(r => { 
        // When clearing form, also update stock display as net movements from form are now 0
        updateCardStockDisplay(r, dateInput.value);
      });
    }

    // Helper function to calculate net movement since the last stock check on the same day
    function netMovementSinceLastCheck(resourceName, forDate, formEntriesToday, lastCheckQty) {
        // This is a simplified version. A robust solution would need entry timestamps.
        // For now, if a stock check was made today, we assume all entries contribute to the delta from that check.
        // This means the baseStock for display is the lastCheckQty, and netMovement is sum(all deliveries) - sum(all usages) for the day.
        // The `displayStock` calculation in `updateCardStockDisplay` already handles this by using `dailyStockCheckOverrides` as the base.
        // So, this function can just return the total net movement for the day if needed for other purposes,
        // or be more complex if we want to show a delta *since* the check.
        // For now, let's assume the main displayStock calculation is sufficient.
        let net = 0;
        formEntriesToday.forEach(entry => {
            if (entry.resource === resourceName) {
                net += (entry.machine.toLowerCase().startsWith('livraison') ? entry.quantity : -entry.quantity);
            }
        });
        return net;
    }

    dateInput.addEventListener('change', (e) => {
        dailyStockCheckOverrides = {}; // Clear overrides when date changes
        loadEntriesForDate(e.target.value);
    });

  </script>

  <!-- Add a general notes field to the form -->
  <div class="form-group">
    <label for="general-notes">General Notes:</label>
    <textarea id="general-notes" name="general-notes" rows="3"></textarea>
  </div>

  <!-- Your application script, including Dexie setup and sync logic -->
  <script defer src="app.js"></script>
</body>
</html>
